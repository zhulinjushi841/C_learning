静态变量和全局变量的区别：
1.如果程序由一个源文件构成的时候，全局变量和全局静态变量没有区别。
2.如果程序由多个源文件构成，全局变量和全局静态变量不同。
3.具有外部链接静态，可以在所有的源文件里调用，除了本文件，其他文件可以通过extern关键字进行引用。

从作用域来看：
(1)全局变量具有全局作用域。

从分配内存空间来看：
全局变量、静态局部变量和静态全局变量都在静态分配区分配空间，而局部变量在栈分配空间。


第12章 存储类别、链接和内存管理
C语言可以让程序员恰到好处地控制程序，程序员可以通过C的内存管理系统指定变量的作用域和生命期，从而实现
对程序的控制。
可以使用存储期(storage duration)描述对象，所谓存储期指的是对象在内存中保留了多长时间，标识符
用于访问对象，可以使用作用域(scope)和链接(linkage)来描述标识符。

12.1.1 作用域
作用域描述程序中可访问标识符的区域。一个C变量的作用域可以是块作用域、函数作用域、函数原型作用域
或文件作用域。块 指的是用一对花括号括起来的代码区域。定义在块中的变量具有块作用域(block scope)。

变量的定义在函数的外面，具有文件作用域(file scope)。具有文件作用域的变量，从它的定义处到该定义所在文件
的末尾处均可见。

12.1.2 链接
C变量具有3种链接属性：外部链接、内部链接或无链接。
[注]编译器把源代码文件和所有的头文件都看成是一个包含信息的单独文件，这个文件被称为翻译单元(translation unit)。
描述一个具有文件作用域的变量时，它的实际可见范围是整个翻译单元。
如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。每个翻译单元均对应
一个源文件代码和它所包含的文件。

具有块作用域、函数作用域或者函数原型作用域的变量都是无链接变量。
外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用。

static关键字既可以表示链接属性(例如对文件作用域变量修饰就意为内部链接)，也可描述其修饰的对象的存储期。
以static声明的文件作用域变量具有内部链接。但是无论是内部链接还是外部链接，所有的文件作用域变量都具有静态存储期。
而对于外部链接的全局变量，在其他文件中使用关键字extern修饰后就可以使用。
因此具有文件作用域的变量既可以是外部链接也可以是内部链接。

12.1.3 存储期
C对象有4种存储期：
静态存储期、线程存储期、自动存储期、动态分配存储期。
如果对象具有静态存储期，那么在程序的执行期间就会一直存在。
线程存储期用于并发程序设计，程序执行可以被分为多个线程。具有线程存储期的对象，从被声明到线程结束会一直存在。
此外，块作用域变量也可以具有静态存储期。为了创建这样的变量，需要把变量声明在块中，且在声明前面加上关键字static。

12.1.5 寄存器变量
变量通常存储在计算机内存中，但是寄存器变量存储在CPU的寄存器中，或者说存储在最快的可用内存中。
与普通变量相比，访问和处理这些变量的速度更快，但是由于寄存器变量存储在寄存器而非内存中，所以无法获取寄存器变量的地址。
在绝大多数方面，寄存器变量和自动变量都一样，均为块作用域、无链接和自动存储期。使用存储类别说明符register便可声明寄存器变量。

12.1.6 块作用域的静态变量
静态变量(static variable)实际上静态的意思为该变量在内存中原地不动，并不是说其值不变。具有文件作用域的变量自动具有(也必须是)静态存储期。
概括来说，块作用域的静态变量具有块作用域，无链接，在块外仍不能访问，但是不会消失。

12.1.7 外部链接的静态变量
外部链接的静态变量具有文件作用域、外部链接和静态存储期。
属于该类型的变量被称为外部变量，把变量的定义性声明放在所有函数的外部便创建了外部变量。
如果一个源文件使用的外部变量定义在另一个源文件中，则必须使用extern在该文件中声明该变量。

12.1.8 内部链接的静态变量
该存储类别的变量具有静态存储期、文件作用域和内部链接。在所有函数外部使用存储类别说明符static定义的变量具有这种存储类别。

12.1.9 多文件
只有当程序由多个翻译单元组成时才能够体现出内部链接和外部链接的重要性。
复杂的C程序通常由多个单独的源文件组成。有时候这些文件可能需要共享一个外部变量。
C通过在一个文件中进行定义式声明，然后在其他文件中进行引用式声明来实现共享。也即是说，出了一个定义式声明之外，其他的声明
都需要使用extern关键字。

注意：extern关键字是为了告诉编译器其声明的函数和变量可以在本模块或者其他模块中使用。通常，在模块的头文件中对本模块
中本模块提供给其他模块引用的函数和全局变量以关键字extern声明。函数的声明extern关键字是可有可无的，因为函数本身不加修饰的话
就是extern的。

12.4 分配内存：malloc() 和 free()
在之前的讨论的存储类别有一个共同之处：在确定哪种存储类别后，根据已制定好的内存管理规则，将自动选择其作用域和存储期。
此外，还有更灵活的方式，也就是使用库函数分配和管理内存。

C可以在程序运行时分配更多的内存。主要的工具是malloc()函数，该函数接受一个参数：所需要的内存字节数。
malloc函数会找到合适的空闲内存块，这样的内存是匿名的。也就是说，malloc函数会分配内存，但不会为其赋名。但是却会返回
动态分配内存块的首字节地址。因此可以将该地址赋给一个指针变量，并使用指针访问这块内存。
从ANSI C标准开始，C使用一个新的类型：指向void的指针。
该类型的指针相当于一个"通用指针"。
malloc()函数可用于返回指向数组的指针、指向结构的指针等，所以通常该函数的返回值会被强制转换为匹配的类型。
如果malloc()函数分配内存失败，将返回空指针。

double *ptd;
ptd = (double*) malloc(30 * sizeof(double));

可以使用表达式ptd[0]来访问该块的首元素，ptd[1]访问第2个元素，以此类推。
通常来说,malloc()需要和free()配套使用。
free()函数的参数是之前malloc()返回的地址，也就是一个指针。该函数用于释放之前malloc()函数分配的内存。
因此，动态分配内存的存储期从调用malloc()分配内存到调用free()释放内存为止。


