第16章 C预处理器和C库


16.5 文件包含：#include
当预处理器发现#include指令时，会查看后面的文件名并把文件的内容包含到当前文件中，也就是替换
源文件中的#include指令。
这相当于把被包含文件的全部内容输入到源文件#include指令所在的位置。
在UNIX系统中，尖括号告诉预处理器在标准系统目录中查找该文件。双引号告诉预处理器首先在
当前目录中(或者文件名中指定的其他目录)查找该文件，如果没找到再查找标准系统目录。

16.5.2 使用头文件
头文件中最常用的形式如下。
1.明示常量
2.宏函数
3.函数声明
4.结构模板定义
5.类型定义

许多程序员都在程序中使用自己开发的标准头文件。如果开发一系列相关的函数或结构，那么这种方法就特别有用。
此外，还可以使用头文件声明外部变量供其他文件共享。
然后，可以在与源文件相关联的头文件中进行引用式声明：
extern int status;	//该变量具有文件作用域，在源代码文件
这行代码会出现在包含该头文件的文件中，这样使用该系列函数的文件都能够使用这个变量。

需要包含头文件的另一种情况是，使用具有文件作用域、内部链接和 const 限定符的变量或数组。
const防止值被意外修改，static 意味着每个包含该头文件的文件都获得一份副本。因此，不需要在一个文件中
进行定义式声明，在其他文件中进行引用式声明。

16.6.3 条件编译
可以使用其他指令创建条件编译(conditional compilation)。也就是说，可以使用这些指令告诉编译器根据编译时的条件执行
或忽略信息块。
1.#ifdef、#else 和 #endif指令
2.#ifndef指令
#ifndef指令与#ifdef指令的用法类似，也可以和#else、#endif一起使用，但是逻辑相反，#ifndef指令判断后面的标识符
是否是未定义的，常用于定义之前未定义的常量。
通常在包含多个头文件时，其中的文件可能包含了相同的宏定义。#ifndef指令可以防止相同的宏被重复定义。
在首次定义一个宏的头文件中使用#ifndef指令激活定义，随后在其他头文件中的定义都被忽略。
防止头文件被重复包含的命令如下：
#ifndef _STDIO_H
#define _STDIO_H
//省略了文件的内容
#endif


16.6.6 #pragma
在现在的编译器中，可以通过命令行参数或者IDE菜单修改编译器的一些设置。#pragma把编译器指令放入源代码中。

16.7 内联函数
通常来说，函数调用都有一定的开销，因为函数的调用过程包括建立调用、传递参数、跳转到函数代码并返回。
使用宏使代码内联，可以避免这样的开销。
C99和C11标准中对内联函数的叙述为：把函数变成内联函数，编译器可能会用内联代码替换函数调用，并(或)执行
一些其他的优化，但是也可能不起作用。
标准规定具有内部链接的函数可以成为内联函数，还规定了内联函数的定义与调用该函数的代码必须在同一个文件中。
因此，最简单的方法是使用函数说明符 inline 和存储类别说明符 static。
通常，内联函数应当定义在首次使用它的文件中，所以内联函数也相当于函数原型。

编译器查看内联函数的定义(也就是原型)，可能会用函数体中的代码替换 其函数调用。也就是说，效果相当于
在函数调用的位置输入函数体中的代码。
内联函数应当比较短小，把较长的函数变为内联函数并不会节约多少时间，因为执行函数体的时间比调用函数的时间长很多。


16.12 断言库
assert.h头文件支持的断言库是一个用于辅助调试程序的小型库。它由assert()组成，接受一个整型表达式作为参数。
如果表达式求值为假(非零),assert()宏就在标准错误流(stderr)中写入一条错误信息，并调用abort()函数终止程序
(abort()函数的原型在stdlib.h头文件中)。assert()函数就是为了标识出程序中某些条件为真的关键位置，如果
其中一个具体条件为假，就用assert()语句终止程序。
如果assert函数终止了程序，它首先会显示失败的测试，包含测试的文件名和行号。
和使用条件语句进行错误判断相比，
使用assert()有几个好处：它不仅能自动标识文件和出问题的行号，还有一种无需更改代码就能开启或者关闭
assert()的机制。如果认为已经排除了程序的bug，就可以把下面的宏定义卸载包含assert.h的位置前面。
#define NDEBUG
并重新编译，这样编译器就会禁用文件中的所有assert()语句。






