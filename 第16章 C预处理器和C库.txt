第16章 C预处理器和C库


16.5 文件包含：#include
当预处理器发现#include指令时，会查看后面的文件名并把文件的内容包含到当前文件中，也就是替换源文件中的#include指令。
这相当于把被包含文件的全部内容输入到源文件#include指令所在的位置。
在UNIX系统中，尖括号告诉预处理器在标准系统目录中查找该文件。双引号告诉预处理器首先在当前目录中(或者文件名中指定的其他目录)查找该文件，如果
没找到再查找标准系统目录。

16.5.2 使用头文件
头文件中最常用的形式如下。
1.明示常量
2.宏函数
3.函数声明
4.结构模板定义
5.类型定义

许多程序员都在程序中使用自己开发的标准头文件。如果开发一系列相关的函数或结构，那么这种方法就特别有用。
此外，还可以使用头文件声明外部变量供其他文件共享。
然后，可以在与源文件相关联的头文件中进行引用式声明：
extern int status;	//该变量具有文件作用域，在源代码文件
这行代码会出现在包含该头文件的文件中，这样使用该系列函数的文件都能够使用这个变量。

需要包含头文件的另一种情况是，使用具有文件作用域、内部链接和 const 限定符的变量或数组。
const防止值被意外修改，static 意味着每个包含该头文件的文件都获得一份副本。因此，不需要在一个文件中进行定义式声明，
在其他文件中进行引用式声明。

16.6.3 条件编译
可以使用其他指令创建条件编译(conditional compilation)。也就是说，可以使用这些指令告诉编译器根据编译时的条件执行
或忽略信息块。
1.#ifdef、#else 和 #endif指令

2.#ifndef指令
#ifndef指令与#ifdef指令的用法类似，也可以和#else、#endif一起使用，但是逻辑相反，#ifndef指令判断后面的标识符
是否是未定义的，常用于定义之前未定义的常量。
通常在包含多个头文件时，其中的文件可能包含了相同的宏定义。#ifndef指令可以防止相同的宏被重复定义。
在首次定义一个宏的头文件中使用#ifndef指令激活定义，随后在其他头文件中的定义都被忽略。
防止头文件被重复包含的命令如下：
#ifndef _STDIO_H
#define _STDIO_H
//省略了文件的内容
#endif


16.6.6 #pragma
在现在的编译器中，可以通过命令行参数或者IDE菜单修改编译器的一些设置。#pragma把编译器指令放入源代码中。

16.7 内联函数
通常来说，函数调用都有一定的开销，因为函数的调用过程包括建立调用、传递参数、跳转到函数代码并返回。
使用宏使代码内联，可以避免这样的开销。
C99和C11标准中对内联函数的叙述为：把函数变成内联函数，编译器可能会用内联代码替换函数调用，并(或)执行
一些其他的优化，但是也可能不起作用。
标准规定具有内部链接的函数可以成为内联函数，还规定了内联函数的定义与调用该函数的代码必须在同一个文件中。
因此，最简单的方法是使用函数说明符 inline 和存储类别说明符 static。
通常，内联函数应当定义在首次使用它的文件中，所以内联函数也相当于函数原型。

编译器查看内联函数的定义(也就是原型)，可能会用函数体中的代码替换 其函数调用。也就是说，效果相当于
在函数调用的位置输入函数体中的代码。
内联函数应当比较短小，把较长的函数变为内联函数并不会节约多少时间，因为执行函数体的时间比调用函数的时间长很多。

